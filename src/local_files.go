// controller
package main

import (
	"encoding/json"
	"flag"
	"fmt"
	"os"
	"path/filepath"
	"strings"
)

func entryFile(commandname string, args []string) {
	var userConfirmed bool

	commandFlags := flag.NewFlagSet(commandname, flag.ExitOnError)
	commandFlags.BoolVar(&userConfirmed, "y", false, "Confirm file overwrites")
	commandFlags.BoolVar(&userConfirmed, "yes", false, "Confirm file overwrites")
	setGlobalArguments(commandFlags)

	commandFlags.Usage = func() {
		printHelpMenu(commandFlags, commandname, allCmdOpts)
	}
	if len(args) < 1 {
		printHelpMenu(commandFlags, commandname, allCmdOpts)
		os.Exit(1)
	}
	commandFlags.Parse(args[1:])
	remainingArgs := commandFlags.Args()

	switch args[0] {
	case "new":
		if len(remainingArgs) < 1 {
			printHelpMenu(commandFlags, args[0], allCmdOpts)
			os.Exit(1)
		}

		writeTemplateFile(remainingArgs[0], userConfirmed)
	case "replace-data":
		if len(remainingArgs) < 2 {
			printHelpMenu(commandFlags, args[0], allCmdOpts)
			os.Exit(1)
		}

		srcFile := remainingArgs[0]
		dstFile := remainingArgs[1]
		replaceFileData(srcFile, dstFile, userConfirmed)
	default:
		printHelpMenu(commandFlags, commandname, allCmdOpts)
		os.Exit(1)
	}
}

// Creates a basic file at the path with JSON metadata header prefilled with example values
func writeTemplateFile(path string, userConfirmed bool) {
	path, err := retrieveURIFile(path)
	logError("Failed to parse files URI", err, false)

	var fileList []string
	if strings.Contains(path, ",") {
		fileList = strings.Split(path, ",")
	} else {
		fileList = append(fileList, path)
	}

	var templateMetadata MetaHeader
	templateMetadata.TargetFilePermissions = 600
	templateMetadata.TargetFileOwnerGroup = "root:root"
	templateMetadata.ReloadCommands = []string{"echo check syntax", "echo reload service", "echo check service"}
	templateMetadata.ReloadGroup = "ServiceGroupName"
	templateMetadata.Dependencies = []string{"host/etc/file1", "host/etc/file2"}
	templateMetadata.CheckCommands = []string{"stat /var/cache/Dir"}
	templateMetadata.InstallCommands = []string{"apt-get install curl -y"}
	templateMetadata.PreDeployCommands = []string{"grep -i a <<<{@LOCALFILEDATA}"}

	templateText := "This is a template file generated by SCMP controller using 'controller file new' command\n"
	templateData := []byte(templateText)

	for _, file := range fileList {
		if fileExists(file) && !userConfirmed {
			printMessage(verbosityStandard, "Warning: Skipping file '%s' because no confirmation was received to overwrite the file\n", file)
			continue
		}

		err = writeLocalRepoFile(file, templateMetadata, &templateData)
		logError("Failed to write new template file", err, false)
	}
}

// Takes all the data in source file and writes it into the destination file without affecting the destination file's metadata header
func replaceFileData(srcFilePath string, dstFilePath string, userConfirmed bool) {
	sourceFile, err := os.ReadFile(srcFilePath)
	logError("Failed to read source file path", err, false)

	destinationFile, err := os.ReadFile(dstFilePath)
	logError("Failed to read destination file path", err, false)

	// Grab existing metadata header
	jsonMetadata, _, err := extractMetadata(string(destinationFile))
	logError(fmt.Sprintf("Failed to separate metadata from content for file %s", destinationFile), err, false)

	var clearedToWrite bool
	if userConfirmed {
		clearedToWrite = true
	} else {
		userResponse, err := promptUser("Type 'yes' to confirm overwrite of file data in '%s': ", dstFilePath)
		logError("Failed to prompt user for confirmation", err, false)

		if strings.ToLower(userResponse) == "yes" {
			clearedToWrite = true
		}
	}

	if !clearedToWrite {
		printMessage(verbosityStandard, "Warning: Not writing new data to file '%s' because no confirmation was received\n", dstFilePath)
		return
	}

	// Write file back to destination using new content from source
	err = writeLocalRepoFile(dstFilePath, jsonMetadata, &sourceFile)
	logError(fmt.Sprintf("Failed to write source file contents from %s to destination %s", srcFilePath, dstFilePath), err, false)
}

// Writes file contents to repository file with added metadata header
// File content optional
func writeLocalRepoFile(localFilePath string, metadata MetaHeader, fileContent *[]byte) (err error) {
	printMessage(verbosityProgress, "Adding JSON metadata header to file '%s'\n", localFilePath)

	var startDelimiter, endDelimiter, metaPrefix string
	switch filepath.Ext(localFilePath) {
	case ".sh", ".zsh", ".bashrc", ".zshrc", ".yaml", ".yml", ".py":
		metaPrefix = "#"
		startDelimiter = metaDelimiter
		endDelimiter = metaDelimiter
	case ".html", ".htm", ".xml":
		startDelimiter = "<!--" + metaDelimiter
		endDelimiter = metaDelimiter + "-->"
	case ".go", ".css", ".js", ".php":
		startDelimiter = "/*" + metaDelimiter
		endDelimiter = metaDelimiter + "*/"
	default:
		startDelimiter = metaDelimiter
		endDelimiter = metaDelimiter
	}

	metaHeaderBytes, err := json.MarshalIndent(metadata, metaPrefix, "  ")
	if err != nil {
		err = fmt.Errorf("error parsing metadata header: %v", err)
	}
	metaHeaderBytes = unescapeShellRedirectors(metaHeaderBytes)
	header := string(metaHeaderBytes)

	var fullFileContent strings.Builder
	fullFileContent.WriteString(startDelimiter)
	fullFileContent.WriteString("\n")
	fullFileContent.WriteString(metaPrefix) // JSON MarshalIndent does not add prefix to the first line
	fullFileContent.WriteString(header)
	fullFileContent.WriteString("\n")
	fullFileContent.WriteString(endDelimiter)
	fullFileContent.WriteString("\n")
	if fileContent != nil {
		fullFileContent.WriteString(string(*fileContent))
	}

	printMessage(verbosityProgress, "Writing file '%s' to repository\n", localFilePath)

	configParentDirs := filepath.Dir(localFilePath)
	err = os.MkdirAll(configParentDirs, 0700)
	if err != nil {
		err = fmt.Errorf("failed to create missing parent directories in local repository: %v", err)
		return
	}

	localFile, err := os.OpenFile(localFilePath, os.O_CREATE|os.O_WRONLY|os.O_TRUNC, 0600)
	if err != nil {
		err = fmt.Errorf("failed to open/create directory metadata file: %v", err)
		return
	}
	defer localFile.Close()

	_, err = localFile.WriteString(fullFileContent.String())
	if err != nil {
		err = fmt.Errorf("failed to write file to local repository: %v", err)
		return
	}

	return
}

func writeSymbolicLinkToRepo(localLinkPath string, selectionMetadata RemoteFileInfo) (err error) {
	var linkMetadata MetaHeader
	linkMetadata.SymbolicLinkTarget = selectionMetadata.linkTarget
	linkMetadata.TargetFileOwnerGroup = "root:root"
	linkMetadata.TargetFilePermissions = 777

	printMessage(verbosityData, "  Symbolic Link '%s': Target: %s\n", localLinkPath, selectionMetadata.linkTarget)

	err = writeLocalRepoFile(localLinkPath, linkMetadata, nil)
	if err != nil {
		err = fmt.Errorf("failed to write directory metadata to local repository: %v", err)
		return
	}

	return
}

// Writes directory metadata of chosen dir to repo
func writeNewDirectoryMetadata(localDirPath string, selectionMetadata RemoteFileInfo) (err error) {
	var dirMetadata MetaHeader
	dirMetadata.TargetFileOwnerGroup = selectionMetadata.owner + ":" + selectionMetadata.group
	dirMetadata.TargetFilePermissions = selectionMetadata.permissions

	printMessage(verbosityData, "  Directory '%s': Metadata: %d %s\n", localDirPath, selectionMetadata.permissions, dirMetadata.TargetFileOwnerGroup)

	metadataFile := filepath.Join(localDirPath, directoryMetadataFileName)

	err = writeLocalRepoFile(metadataFile, dirMetadata, nil)
	if err != nil {
		err = fmt.Errorf("failed to write directory metadata to local repository: %v", err)
		return
	}

	return
}

func handleArtifactFiles(localFilePath *string, fileContents *[]byte, optCache *SeedRepoUserChoiceCache) (externalContentLocation string, err error) {
	fileIsPlainText := isText(fileContents)

	// Return early if file is not an artifact
	if fileIsPlainText {
		printMessage(verbosityProgress, "  File is plain text, not running artifact handling logic\n")
		return
	}

	// Repetitive artifact dirs - find most reused to suggest to user
	var mostReusedDir string
	var highestNum int
	for artifactDir, dirRepeatCnt := range optCache.artifactExtDir {
		if dirRepeatCnt < 2 {
			continue
		}

		if dirRepeatCnt > highestNum {
			highestNum = dirRepeatCnt
		}

		mostReusedDir = artifactDir
	}

	// Make file depending on if plain text or binary
	var userResponse string
	printMessage(verbosityStandard, "  File is not plain text, it should probably be stored outside of git\n")
	fmt.Print("  Specify a directory path where the actual file should be stored or enter 'none' to store file directly in repository\n")
	if mostReusedDir != "" {
		fmt.Printf("Default (press enter): '%v'\n", mostReusedDir)
	}

	fmt.Print("Path to External Directory: ")
	fmt.Scanln(&userResponse)

	if strings.ToLower(userResponse) == "none" || (userResponse == "" && mostReusedDir == "") {
		printMessage(verbosityProgress, "  Did not receive an external content location for artifact, ARTIFACT CONTENTS WILL BE STORED IN REPOSITORY\n")
		return
	}

	if userResponse == "" {
		userResponse = mostReusedDir
	}

	// Ensure artifact fileContents are not written into repository
	defer func() {
		*fileContents = nil
	}()

	artifcateFileDirectory := userResponse
	remoteFileName := filepath.Base(*localFilePath)

	artifactFilePath := filepath.Join(artifcateFileDirectory, remoteFileName)

	// Clean up user supplied path
	artifactFilePath, err = filepath.Abs(artifactFilePath)
	if err != nil {
		return
	}

	optCache.artifactExtDir[fmt.Sprintf("%v", artifactFilePath)]++

	// Store real file path in git-tracked file (set URI prefix)
	externalContentLocation = fileURIPrefix + artifactFilePath

	err = os.MkdirAll(filepath.Dir(artifactFilePath), 0750)
	if err != nil {
		return
	}

	artifactFile, err := os.OpenFile(artifactFilePath, os.O_CREATE|os.O_WRONLY|os.O_TRUNC, 0600)
	if err != nil {
		return
	}
	defer artifactFile.Close()

	_, err = artifactFile.Write(*fileContents)
	if err != nil {
		return
	}

	// Add extension to mark file as external
	*localFilePath += artifactPointerFileExtension

	return
}
